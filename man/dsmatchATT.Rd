% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dsmatchATT.R
\name{dsmatchATT}
\alias{dsmatchATT}
\title{Double Score Matching Estimator for Average Treatment Effect for the Treated.}
\usage{
dsmatchATT(Y, X, A, method = "dsm", model.ps = "other", ps = NULL,
  lp.ps = NULL, model.pg = "other", pg = NULL, lp.pg = NULL,
  cov.balance = F, varest = F, boots = 100, mc = F, ncpus = 4)
}
\arguments{
\item{Y}{Outcome as numeric vector.}

\item{X}{Covarites as numeric vector or matrix.}

\item{A}{Treatment assignment as numeric vector with \code{1} stands for
treatment group and \code{0} stands for control group.}

\item{method}{Matching method to use, including \code{"dsm"} as double
score matching, \code{"ps"} as propensity score matching, \code{"pg"}
as prognostic score matching and \code{"cov"} as matching on covariates
directly.}

\item{model.ps}{Fitted model for propensity score, including
\code{"logit"} as logistic model, \code{"probit"} as probit model,
\code{"linpred"} as logistic model with linear predictors specified by
\code{"lp.ps"}. Don't need to be specified if \code{ps} is given.}

\item{ps}{Propensity score as numeric vector given by user. Don't need
to be specified if \code{model.ps} is given.}

\item{lp.ps}{Linear predictors for propensity score as numeric vector or
matrix. Don't need to be specified if \code{model.ps} is not
\code{"linpred"}.}

\item{model.pg}{Fitted model for prognostic score, including
\code{"glm"} as linear model for continuous outcome, \code{"glm_logit"}
as logistic model for binary outcome, \code{"glm_probit"} as probit model
for binary outcome, \code{"linpred"} as linear model for continuous
outcome with linear predictors specified by \code{"lp.pg"},
\code{"zir_logit"} as zero inflated model using logistic model to fit
non-zero probability, \code{"zir_probit"} as zero inflated model using
probit model to fit non-zero probability. Don't need to be specified if
\code{pg} is given.}

\item{pg}{Prognostic score as numeric matrix given by user. The first
column is potential outcome for control group and the second column is
potential outcome for treatment group. Don't need to be specified if
\code{model.pg} is given.}

\item{lp.pg}{Linear predictors for prognostic score as numeric vector or
matrix. Don't need to be specified if \code{model.pg} is not
\code{"linpred"}.}

\item{cov.balance}{A logical scalar for whether covariance balance
results should be shown.}

\item{varest}{A logical scalar for whether variance of estimator should
be estimated.}

\item{boots}{A numeric scalar for number of bootstrap relicates in
variance estimation. Don't need to be specified if \code{varest} is
\code{F}.}

\item{mc}{A logical scalar for whether multiple cores are used in
variance estimation. Don't need to be specified if \code{varest} is
\code{F}.}

\item{ncpus}{A numeric scalar for number of cores used in
variance estimation. Don't need to be specified if \code{varest} is
\code{F}.}
}
\value{
Results are put in a list:
  \item{est.ds}{Point estimate of ATT if matching is based on
  double score}
  \item{est.ps}{Point estimate of ATT if matching is based on
  propensity score}
  \item{est.pg}{Point estimate of ATT if matching is based on
  prognostic score}
  \item{est.x}{Point estimate of ATT if matching is based on
  covarites directly}
  \item{boot.var}{Variance of estimator estimated by bootstrap.
  Meaningless if \code{varest} if \code{F}.}
  \item{bootq1}{0.025 quantile of estimator estimated by bootstrap.
  Meaningless if \code{varest} if \code{F}.}
  \item{bootq2}{0.975 quantile of estimator estimated by bootstrap.
  Meaningless if \code{varest} if \code{F}.}
}
\description{
\code{dsmatchATT} applys matching algorithm to estimate average
treatment effect for the treated based on propensity score and prognostic score.
Classical matching algortihms, including propensity score matching,
prognositc score matching and matching directly on covarites are
also contained for comparison. Covariate balance results are also
provided.
}
\details{
For both propensity socre and prognostic score, user should either
select a model or provide the score directly. If linear predictors
are used to fit a logistic model for propensity score or a linear
model for prognostic score, they should be determined by
\code{lp.ps} or \code{lp.pg} argument. If \code{model.ps} (and
\code{lp.ps} if linear predictors are used) is given, then
\code{ps} does not need to be specified, and vice versa. However,
if propensity socre is given by \code{ps} while \code{model.ps}
is chosen at the same time, the model will be ignored and matching
will be based on the score given by the user directly. A warning
will be thrown if this situation happens. Similar results for
prognostic score.

A special model for prognostic score is the zero inflated regression
 model, which fits a logistic model for the probability to be zero,
 and a regression model for the non-zero values.
}
\examples{
# import lalonde data from package "lalonde"
library(lalonde)
nsw <- lalonde::nsw
cps3 <- lalonde::cps_controls3

# combine datasets
nsw <- nsw[,-1]
cps3 <- cps3[,c(2,3,4,5,6,7,8,10,11)]
lalonde <- rbind(nsw, cps3)

# preprocessing of data
Y = lalonde[,"re78"]
Y = as.matrix(Y)
Y = as.vector(Y)
X = lalonde[,c("age","education","black","hispanic","married","nodegree","re75")]
X = as.matrix(X)
A = lalonde[,"treat"]
A = as.matrix(A)
A = as.vector(A)

# linear predictors using in the algorithm
# take logarithm for income and standardize covariates
Z = X
Z[,"re75"] = log(Z[,"re75"] + 1)
Z[,"age"] = (Z[,"age"] - mean(Z[,"age"])) / sd(Z[,"age"])
Z[,"education"] = (Z[,"education"] - mean(Z[,"education"])) / sd(Z[,"education"])
Z[,"re75"] = (Z[,"re75"] - mean(Z[,"re75"])) / sd(Z[,"re75"])
Z = cbind(X, Z[,"age"]^2, Z[,"education"]^2, Z[,"re75"]^2)

# estimate ATT using four matching methods
set.seed(1)
dsmatchATT(Y, X, A, method = "dsm", model.ps = "linpred", lp.ps = Z, model.pg = "linpred", lp.pg = Z, varest = T, cov.balance = T)
dsmatchATT(Y, X, A, method = "ps", model.ps = "linpred", lp.ps = Z, model.pg = "linpred", lp.pg = Z, varest = T, cov.balance = T)
dsmatchATT(Y, X, A, method = "pg", model.ps = "linpred", lp.ps = Z, model.pg = "linpred", lp.pg = Z, varest = T, cov.balance = T)
dsmatchATT(Y, X, A, method = "cov", model.ps = "linpred", lp.ps = Z, model.pg = "linpred", lp.pg = Z, varest = T, cov.balance = T)

# estimate QTT using double score matching
p = 0.3
set.seed(1)
res <- dsmatchQTT(Y, X, A, p, method = "dsm", model.ps = "linpred", lp.ps = Z, model.pg = "linpred", lp.pg = Z, varest = T)
res
# Wald interval for QTT
res$est.ds + qnorm(0.025) * sqrt(res$bootvar)
res$est.ds - qnorm(0.025) * sqrt(res$bootvar)

}
